//#define LAUNCH_DEBUGGER

using System.IO;
using System.Linq;
using System.Reflection;
using System.Threading;
using System.Xml.Linq;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace DotVast.Toolkit.StringResource.SourceGenerators;

[Generator(LanguageNames.CSharp)]
public sealed class StringResourceGenerator : IIncrementalGenerator
{
    private static readonly AssemblyName s_assemblyName = typeof(StringResourceGenerator).Assembly.GetName();
    private static readonly string s_generatedCodeAttribute = $"""
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("{s_assemblyName.Name}", "{s_assemblyName.Version}")]
        """;
    private const string ExcludeFromCodeCoverageAttribute = "[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]";

    private const string StringResourceAttributeName = "DotVast.Toolkit.StringResource.StringResourceAttribute";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
#if LAUNCH_DEBUGGER
        if (!System.Diagnostics.Debugger.IsAttached)
        {
            System.Diagnostics.Debugger.Launch();
        }
#endif
        var infos = context.SyntaxProvider
            .ForAttributeWithMetadataName(StringResourceAttributeName, Predicate, Transfrom)
            .Where(static i => i != default);

        context.RegisterSourceOutput(infos, GenerateCode);
    }

    private static bool Predicate(SyntaxNode node, CancellationToken token) =>
        node is ClassDeclarationSyntax;

    private static StringResourceInfo Transfrom(GeneratorAttributeSyntaxContext context, CancellationToken token)
    {
        if (context.TargetSymbol is not ITypeSymbol type)
        {
            return default;
        }

        // context.Attributes 仅包含目标特性
        if (GetAttributeCtorArgsValue(context.Attributes.FirstOrDefault()) is not object[] args)
        {
            return default;
        }

        // see DotVast.Toolkit.StringResource.StringResourceAttribute..ctor
        var (reswPath, propertyFormat, usings) = args.Length switch
        {
            2 => (args[0] as string, args[1] as string, null),
            3 => (args[0] as string, args[1] as string, args[2] as string),
            _ => (null, null, null),
        };

        var basePath = context.TargetNode.SyntaxTree.FilePath;
        var fullPath = Path.GetFullPath(Path.Combine(basePath, reswPath?.Trim() ?? string.Empty));
        if (!fullPath.EndsWith(".resw", System.StringComparison.OrdinalIgnoreCase) || !File.Exists(fullPath))
        {
            return default;
        }

        if (propertyFormat is null)
        {
            return default;
        }

        var lastWriteTime = File.GetLastWriteTime(fullPath);
        var className = type.Name;
        var namespaceName = type.ContainingNamespace.IsGlobalNamespace
            ? string.Empty
            : type.ContainingNamespace.ToDisplayString();

        return new StringResourceInfo(fullPath, lastWriteTime, className, namespaceName, propertyFormat, usings);
    }

    private static void GenerateCode(SourceProductionContext context, StringResourceInfo info)
    {
        var isb = new IndentedStringBuilder("    ");

        isb.AppendLine("// <auto-generated/>");
        isb.AppendLine("#pragma warning disable");
        isb.AppendLine("#nullable enable");
        isb.AppendLine("");

        if (!string.IsNullOrEmpty(info.NamespaceName))
        {
            isb.AppendLine($"namespace {info.NamespaceName};");
            isb.AppendLine("");
        }

        if (!string.IsNullOrEmpty(info.Usings))
        {
            using var sr = new StringReader(info.Usings);
            while (sr.ReadLine() is string line)
            {
                isb.AppendLine(line);
            }
            isb.AppendLine("");
        }

        isb.AppendLine($"partial class {info.ClassName}");
        isb.Append("{");
        isb.Indent++;

        foreach (var item in XElement.Load(info.ReswPath).Elements("data"))
        {
            if (item.Attribute("name")?.Value is not string name || name.Contains("."))
            {
                continue;
            }
            isb.AppendLine("");

            if (item.Element("value")?.Value is string value)
            {
                isb.AppendLine($"/// <value>");
                isb.AppendLine($"/// <![CDATA[{value}]]>");
                isb.AppendLine($"/// </value>");
            }

            if (item.Element("comment")?.Value is string comment)
            {
                isb.AppendLine($"/// <remarks>");
                isb.AppendLine($"/// <![CDATA[{comment}]]>");
                isb.AppendLine($"/// </remarks>");
            }

            isb.AppendLine(s_generatedCodeAttribute);
            isb.AppendLine(ExcludeFromCodeCoverageAttribute);

            using var sr = new StringReader(info.PropertyFormat);
            while (sr.ReadLine() is string line)
            {
                isb.AppendFormat(line, name);
                isb.AppendLine("");
            }
        }

        isb.Indent--;
        isb.AppendLine("}");

        var qualifiedName = info.NamespaceName is null ? info.ClassName : $"{info.NamespaceName}.{info.ClassName}";
        context.AddSource($"{qualifiedName}.g.cs", isb.ToString());
    }

    private static object?[]? GetAttributeCtorArgsValue(AttributeData? attributeData) =>
        attributeData?.ConstructorArguments.Select(arg => arg.Value).ToArray();
}

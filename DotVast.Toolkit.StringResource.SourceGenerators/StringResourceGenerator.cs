using System.Collections.Immutable;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Threading;
using System.Xml.Linq;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace DotVast.Toolkit.StringResource.SourceGenerators;

[Generator(LanguageNames.CSharp)]
public sealed class StringResourceGenerator : IIncrementalGenerator
{
    private static readonly AssemblyName s_assemblyName = typeof(StringResourceGenerator).Assembly.GetName();
    private static readonly string s_generatedCodeAttribute = $"""
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("{s_assemblyName.Name}", "{s_assemblyName.Version}")]
        """;
    private const string ExcludeFromCodeCoverageAttribute = "[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]";

    private const string TargetAttributeName = "DotVast.Toolkit.StringResource.StringResourceAttribute";
    private const string TargetAttributeQualifiedName = "global::DotVast.Toolkit.StringResource.StringResourceAttribute";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var infos = context.SyntaxProvider
            .ForAttributeWithMetadataName(TargetAttributeName, Predicate, Transfrom)
            .Where(static i => i != default);

        context.RegisterSourceOutput(infos, GenerateCode);
    }

    private static bool Predicate(SyntaxNode node, CancellationToken token) =>
        node is ClassDeclarationSyntax;

    private static StringResourceInfo Transfrom(GeneratorAttributeSyntaxContext context, CancellationToken token)
    {
        if (context.TargetSymbol is not ITypeSymbol type
            || GetAttributeCtorArgsValue(context.Attributes, TargetAttributeQualifiedName) is not object?[] args)
        {
            return default;
        }

        // see DotVast.Toolkit.StringResource.StringResourceAttribute..ctor
        var (reswPath, extensionMethod, extensionMethodNamespace) = args.Length switch
        {
            1 => (args[0] as string, null, null),
            2 => (args[0] as string, args[1] as string, null),
            3 => (args[0] as string, args[1] as string, args[2] as string),
            _ => (null, null, null),
        };

        var basePath = context.TargetNode.SyntaxTree.FilePath;
        var fullPath = Path.GetFullPath(Path.Combine(basePath, reswPath?.Trim() ?? string.Empty));
        if (!fullPath.EndsWith(".resw", System.StringComparison.OrdinalIgnoreCase) || !File.Exists(fullPath))
        {
            return default;
        }

        var classNamespace = type.ContainingNamespace.IsGlobalNamespace
            ? null
            : type.ContainingNamespace.ToDisplayString();
        var className = type.Name;
        var lastWriteTime = File.GetLastWriteTime(fullPath);

        extensionMethod = extensionMethod?.Trim();
        extensionMethod = extensionMethod != null && !extensionMethod.EndsWith(")")
            ? $"{extensionMethod}()"
            : extensionMethod;
        extensionMethodNamespace = extensionMethodNamespace?.Trim();

        return new StringResourceInfo(classNamespace, className, fullPath, lastWriteTime, extensionMethod, extensionMethodNamespace);
    }

    private static void GenerateCode(SourceProductionContext context, StringResourceInfo info)
    {
        var extension = info.ExtensionMethod != null ? $".{info.ExtensionMethod}" : string.Empty;
        var sb = new StringBuilder();

        sb.AppendLine("""
            // <auto-generated/>
            #pragma warning disable
            #nullable enable
            
            """);

        if (info.ExtensionMethedNamespace != null)
            sb.AppendLine($"""
            using {info.ExtensionMethedNamespace};

            """);

        if (info.Namespace != null)
            sb.AppendLine($"""
            namespace {info.Namespace};

            """);

        sb.Append($$"""
            partial class {{info.Name}}
            {
            """);

        foreach (var item in XElement.Load(info.ReswPath).Elements("data"))
        {
            if (item.Attribute("name")?.Value is not string name || name.Contains("."))
                continue;

            if (item.Element("value")?.Value is string value)
                sb.AppendLine($"""

                /// <value>
                /// <![CDATA[{value}]]>
                /// </value>
            """);

            if (item.Element("comment")?.Value is string comment)
                sb.AppendLine($"""
                /// <remarks>
                /// <![CDATA[{comment}]]>
                /// </remarks>
            """);

            sb.AppendLine($"""
                {s_generatedCodeAttribute}
                {ExcludeFromCodeCoverageAttribute}
                public static string {name} => "{name}"{extension};
            """);
        }

        sb.AppendLine("""
            }
            """);

        var qualifiedName = info.Namespace == null ? info.Name : $"{info.Namespace}.{info.Name}";
        context.AddSource($"{qualifiedName}.g.cs", sb.ToString());
    }

    private static object?[]? GetAttributeCtorArgsValue(ImmutableArray<AttributeData> attributeData, string attributeQualifiedName) =>
        attributeData.FirstOrDefault(d => d.AttributeClass?.HasFullyQualifiedName(attributeQualifiedName) == true)
            ?.ConstructorArguments.Select(arg => arg.Value).ToArray();
}

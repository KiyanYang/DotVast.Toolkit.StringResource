//#define LAUNCH_DEBUGGER

using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Threading;
using System.Xml.Linq;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace DotVast.Toolkit.StringResource.SourceGenerators;

[Generator(LanguageNames.CSharp)]
public sealed class StringResourceGenerator : IIncrementalGenerator
{
    private static readonly AssemblyName s_assemblyName = typeof(StringResourceGenerator).Assembly.GetName();
    private static readonly string s_generatedCodeAttribute = $"""
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("{s_assemblyName.Name}", "{s_assemblyName.Version}")]
        """;
    private const string ExcludeFromCodeCoverageAttribute = "[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]";

    private const string StringResourceAttributeName = "DotVast.Toolkit.StringResource.StringResourceAttribute";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
#if LAUNCH_DEBUGGER
        if (!Debugger.IsAttached)
        {
            Debugger.Launch();
        }
#endif
        var infos = context.SyntaxProvider
            .ForAttributeWithMetadataName(StringResourceAttributeName, Predicate, Transfrom)
            .Where(static i => i != default);

        context.RegisterSourceOutput(infos, GenerateCode);
    }

    private static bool Predicate(SyntaxNode node, CancellationToken token) =>
        node is ClassDeclarationSyntax;

    private static StringResourceInfo Transfrom(GeneratorAttributeSyntaxContext context, CancellationToken token)
    {
        if (context.TargetSymbol is not ITypeSymbol type)
        {
            return default;
        }

        // context.Attributes 仅包含目标特性
        if (GetAttributeCtorArgsValue(context.Attributes.FirstOrDefault()) is not object[] args)
        {
            return default;
        }

        // see DotVast.Toolkit.StringResource.StringResourceAttribute..ctor
        var (reswPath, extensionMethodName, extensionNamespaceName) = args.Length switch
        {
            1 => (args[0] as string, null, null),
            2 => (args[0] as string, args[1] as string, null),
            3 => (args[0] as string, args[1] as string, args[2] as string),
            _ => (null, null, null),
        };

        var basePath = context.TargetNode.SyntaxTree.FilePath;
        var fullPath = Path.GetFullPath(Path.Combine(basePath, reswPath?.Trim() ?? string.Empty));
        if (!fullPath.EndsWith(".resw", System.StringComparison.OrdinalIgnoreCase) || !File.Exists(fullPath))
        {
            return default;
        }

        var lastWriteTime = File.GetLastWriteTime(fullPath);
        var className = type.Name;
        var namespaceName = type.ContainingNamespace.IsGlobalNamespace
            ? null
            : type.ContainingNamespace.ToDisplayString();

        extensionMethodName = extensionMethodName?.Trim();
        extensionMethodName = extensionMethodName is not null && !extensionMethodName.EndsWith(")")
            ? $"{extensionMethodName}()"
            : extensionMethodName;
        extensionNamespaceName = extensionNamespaceName?.Trim();

        return new StringResourceInfo(fullPath, lastWriteTime, className, namespaceName, extensionMethodName, extensionNamespaceName);
    }

    private static void GenerateCode(SourceProductionContext context, StringResourceInfo info)
    {
        var extension = info.ExtensionMethodName != null ? $".{info.ExtensionMethodName}" : string.Empty;
        var sb = new StringBuilder();

        sb.AppendLine("""
            // <auto-generated/>
            #pragma warning disable
            #nullable enable
            
            """);

        if (info.NamespaceName != null)
        {
            sb.AppendLine($"""
            namespace {info.NamespaceName};

            """);
        }

        if (info.ExtensionNamespaceName != null)
        {
            sb.AppendLine($"""
            using {info.ExtensionNamespaceName};

            """);
        }

        sb.Append($$"""
            partial class {{info.ClassName}}
            {
            """);

        foreach (var item in XElement.Load(info.ReswPath).Elements("data"))
        {
            if (item.Attribute("name")?.Value is not string name || name.Contains("."))
            {
                continue;
            }

            if (item.Element("value")?.Value is string value)
            {
                sb.AppendLine($"""

                /// <value>
                /// <![CDATA[{value}]]>
                /// </value>
            """);
            }

            if (item.Element("comment")?.Value is string comment)
            {
                sb.AppendLine($"""
                /// <remarks>
                /// <![CDATA[{comment}]]>
                /// </remarks>
            """);
            }

            sb.AppendLine($"""
                {s_generatedCodeAttribute}
                {ExcludeFromCodeCoverageAttribute}
                public static string {name} => "{name}"{extension};
            """);
        }

        sb.AppendLine("""
            }
            """);

        var qualifiedName = info.NamespaceName is null ? info.ClassName : $"{info.NamespaceName}.{info.ClassName}";
        context.AddSource($"{qualifiedName}.g.cs", sb.ToString());
    }

    private static object?[]? GetAttributeCtorArgsValue(AttributeData? attributeData) =>
        attributeData?.ConstructorArguments.Select(arg => arg.Value).ToArray();
}
